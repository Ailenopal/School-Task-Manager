<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time School Task Manager</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font family -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* Unique Gradient Background */
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            background-attachment: fixed;
        }

        /* Glassmorphism Effect for Main Container */
        .glassmorphic-card {
            background-color: rgba(255, 255, 255, 0.2); /* Semi-transparent white background */
            backdrop-filter: blur(15px); /* The key glass effect */
            border: 1px solid rgba(255, 255, 255, 0.4); /* Light border */
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); /* Subtle, deep shadow */
        }

        .task-list-item {
            transition: all 0.3s ease;
            /* Lighter glass effect for items */
            background-color: rgba(255, 255, 255, 0.5); 
            backdrop-filter: blur(5px);
            border-left: 5px solid transparent; /* Default border */
        }

        .completed-task {
            opacity: 0.6;
            text-decoration: line-through;
            border-left: 5px solid #6ee7b7; /* Subtle visual cue for complete */
        }

        /* Custom scrollbar for task list - adjusted for dark thumb */
        #taskListContainer::-webkit-scrollbar {
            width: 8px;
        }
        #taskListContainer::-webkit-scrollbar-thumb {
            background-color: #a0aec0;
            border-radius: 10px;
        }

        /* Editable fields style */
        .editable-field {
            cursor: pointer;
            padding: 2px 4px; 
            border-radius: 4px;
            display: inline-block;
            max-width: 100%;
        }
        .editable-field:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8 flex justify-center items-start pt-10">

    <!-- Apply the Glassmorphic class -->
    <div id="appContainer" class="w-full max-w-2xl glassmorphic-card rounded-3xl p-6 sm:p-8 lg:p-10">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-indigo-900 mb-2 tracking-tight drop-shadow-sm">
            School Task Manager
        </h1>
        <p class="text-indigo-800 mb-6 border-b border-indigo-200 pb-4">
            Manage your assignments and deadlines in real-time.
        </p>

        <!-- User/Status Bar -->
        <div class="mb-6 p-3 bg-white/50 rounded-lg shadow-inner flex items-center justify-between text-sm border border-white/50">
            <span id="authStatus" class="text-indigo-700 font-semibold">Initializing...</span>
            <span id="userIdDisplay" class="text-xs text-indigo-600 truncate max-w-[50%]"></span>
        </div>

        <!-- Task Input Form (Updated with Subject and Teacher) -->
        <form id="taskForm" class="grid grid-cols-1 sm:grid-cols-4 gap-3 mb-8 p-4 bg-white/50 rounded-xl shadow-lg border border-white/70">
            <input type="text" id="taskSubject" placeholder="Subject (e.g., Chemistry)"
                   class="col-span-1 sm:col-span-2 p-3 border-none bg-white/80 rounded-lg focus:ring-indigo-400 focus:border-indigo-400 text-gray-800 placeholder-gray-500 shadow-inner"
                   required>

            <input type="text" id="taskTeacher" placeholder="Teacher (Optional)"
                   class="col-span-1 sm:col-span-2 p-3 border-none bg-white/80 rounded-lg focus:ring-indigo-400 focus:border-indigo-400 text-gray-800 placeholder-gray-500 shadow-inner">

            <input type="text" id="taskTitle" placeholder="Assignment Title (e.g., Essay Draft)"
                   class="col-span-1 sm:col-span-2 p-3 border-none bg-white/80 rounded-lg focus:ring-indigo-400 focus:border-indigo-400 text-gray-800 placeholder-gray-500 shadow-inner"
                   required>

            <input type="date" id="taskDueDate" title="Due Date"
                   class="col-span-1 sm:col-span-2 p-3 border-none bg-white/80 rounded-lg focus:ring-indigo-400 focus:border-indigo-400 text-gray-800 shadow-inner"
                   required>
                   
            <button type="submit"
                    class="col-span-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition duration-200 ease-in-out shadow-xl transform hover:scale-[1.01] active:scale-[0.99] focus:ring-4 focus:ring-indigo-300">
                Add Task
            </button>
        </form>

        <!-- Task List Container -->
        <div id="taskListContainer" class="space-y-3 max-h-[60vh] overflow-y-auto">
            <!-- Tasks will be injected here -->
            <p id="loadingIndicator" class="text-center text-indigo-300">Loading tasks...</p>
        </div>

    </div>

    <!-- Firebase SDKs and Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, updateDoc, deleteDoc, onSnapshot, query, orderBy, doc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase and App State variables
        let app, db, auth;
        let userId = null;
        let isAuthReady = false;

        // Firestore paths using the provided global variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const taskForm = document.getElementById('taskForm');
        const taskListContainer = document.getElementById('taskListContainer');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const authStatusElement = document.getElementById('authStatus');
        const userIdDisplayElement = document.getElementById('userIdDisplay');

        // --- Utility Functions ---

        /**
         * Generates the Firestore collection path for the current user's tasks.
         * @returns {string} The full Firestore path.
         */
        function getTaskCollectionPath() {
            if (!userId) {
                console.error("Attempted to get collection path before userId was set.");
                return null;
            }
            // Private data storage path: /artifacts/{appId}/users/{userId}/school-tasks
            return `artifacts/${appId}/users/${userId}/school-tasks`;
        }

        // --- Firebase Initialization and Authentication ---

        async function initializeFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config is missing. Cannot initialize Firebase.");
                authStatusElement.textContent = "Error: Config Missing";
                return;
            }

            try {
                // Set debug logging for Firestore
                setLogLevel('Debug');

                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                authStatusElement.textContent = "Authenticating...";

                // Sign in using custom token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // Listen for Auth State Changes
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        authStatusElement.textContent = "Ready";
                        userIdDisplayElement.textContent = `User ID: ${userId}`;
                        console.log("Authentication successful. User ID:", userId);
                        // Start listening to tasks once auth is confirmed
                        setupRealtimeListener();
                    } else {
                        userId = null;
                        isAuthReady = true; // Still ready, but anonymous or signed out
                        authStatusElement.textContent = "Signed Out/Anon";
                        userIdDisplayElement.textContent = "";
                        console.log("No user signed in.");
                        // Clear tasks if signed out/anon and re-rendering is needed
                        renderTasks([]);
                    }
                });

            } catch (error) {
                console.error("Error during Firebase initialization or authentication:", error);
                authStatusElement.textContent = "Auth Error";
            }
        }

        // --- CRUD Operations (Firestore) ---

        /**
         * Adds a new task document to Firestore, now including subject and teacher.
         * @param {string} title - The title of the task.
         * @param {string} dueDate - The due date string.
         * @param {string} subject - The subject of the task.
         * @param {string} teacher - The teacher name (optional).
         */
        async function addTask(title, dueDate, subject, teacher) {
            if (!db || !userId) {
                console.error("Database not ready or user not authenticated.");
                return;
            }

            try {
                const docRef = await addDoc(collection(db, getTaskCollectionPath()), {
                    title: title,
                    dueDate: dueDate,
                    subject: subject,
                    teacher: teacher,
                    completed: false,
                    createdAt: serverTimestamp() // Use server timestamp for creation time
                });
                console.log("Document written with ID: ", docRef.id);
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        }
        
        /**
         * Updates a specific field of a task document in Firestore.
         * @param {string} taskId - The ID of the document to update.
         * @param {string} fieldName - The name of the field to update (e.g., 'title', 'subject').
         * @param {string} newValue - The new value for the field.
         */
        async function updateTaskField(taskId, fieldName, newValue) {
            if (!db || !userId) return;

            const trimmedValue = newValue.trim();
            
            // Only enforce non-empty for mandatory fields (title, subject, due date is handled by form)
            if (trimmedValue === '' && (fieldName === 'title' || fieldName === 'subject')) {
                 console.warn(`Attempted to save empty value for mandatory field: ${fieldName}`);
                 return; 
            }
            
            // Construct update object
            const updateData = {};
            updateData[fieldName] = trimmedValue;

            try {
                const taskRef = doc(db, getTaskCollectionPath(), taskId);
                await updateDoc(taskRef, updateData);
                console.log(`Task ${fieldName} updated for ID:`, taskId);
            } catch (e) {
                console.error(`Error updating document ${fieldName}: `, e);
            }
        }


        /**
         * Toggles the completion status of a task.
         * @param {string} taskId - The ID of the document to update.
         * @param {boolean} currentStatus - The current completion status.
         */
        async function toggleTaskCompletion(taskId, currentStatus) {
            if (!db || !userId) return;

            try {
                const taskRef = doc(db, getTaskCollectionPath(), taskId);
                await updateDoc(taskRef, {
                    completed: !currentStatus
                });
                console.log("Task completion toggled for ID:", taskId);
            } catch (e) {
                console.error("Error toggling document status: ", e);
            }
        }

        /**
         * Deletes a task document from Firestore.
         * @param {string} taskId - The ID of the document to delete.
         */
        async function deleteTask(taskId) {
            if (!db || !userId) return;

            try {
                const taskRef = doc(db, getTaskCollectionPath(), taskId);
                await deleteDoc(taskRef);
                console.log("Task deleted with ID:", taskId);
            } catch (e) {
                console.error("Error deleting document: ", e);
            }
        }

        // --- Real-time Listener and Rendering ---

        /**
         * Sets up the real-time listener for the task collection.
         */
        function setupRealtimeListener() {
            if (!db || !userId) return;

            const tasksCollectionRef = collection(db, getTaskCollectionPath());
            // Query: Get all tasks
            const q = query(tasksCollectionRef);

            loadingIndicator.style.display = 'block';

            // onSnapshot sets up the real-time listener
            onSnapshot(q, (querySnapshot) => {
                const tasks = [];
                querySnapshot.forEach((doc) => {
                    tasks.push({ id: doc.id, ...doc.data() });
                });
                // Sort locally: Incomplete tasks first, then by due date, then by creation date.
                tasks.sort((a, b) => {
                    // 1. Sort by completion status (incomplete first)
                    if (a.completed !== b.completed) {
                        return a.completed ? 1 : -1;
                    }
                    // 2. Sort by due date (earlier dates first)
                    if (a.dueDate && b.dueDate) {
                        return new Date(a.dueDate) - new Date(b.dueDate);
                    }
                    // 3. Fallback to creation time
                    return (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0);
                });

                renderTasks(tasks);
                loadingIndicator.style.display = 'none';
            }, (error) => {
                console.error("Error listening to collection:", error);
                taskListContainer.innerHTML = '<p class="text-red-500 text-center">Error loading tasks. Check console for details.</p>';
                loadingIndicator.style.display = 'none';
            });
        }

        /**
         * Renders the list of tasks to the DOM.
         * @param {Array<Object>} tasks - The array of task objects from Firestore.
         */
        function renderTasks(tasks) {
            taskListContainer.innerHTML = '';

            if (tasks.length === 0) {
                taskListContainer.innerHTML = `
                    <div class="p-6 text-center rounded-lg border border-indigo-200 bg-white/50">
                        <p class="text-indigo-600 font-medium">No tasks yet! Add your first assignment above.</p>
                    </div>
                `;
                return;
            }

            tasks.forEach(task => {
                const isCompleted = task.completed;
                const taskItem = document.createElement('div');
                
                // Apply unique styling class
                taskItem.className = `task-list-item flex items-center p-4 rounded-lg shadow-md border border-white/50 ${isCompleted ? 'completed-task' : 'hover:bg-white/70'}`;
                taskItem.dataset.id = task.id;

                // Format Due Date
                const formattedDate = new Date(task.dueDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                
                // Set default/fallback values for new fields
                const subjectText = task.subject ? `Subject: ${task.subject}` : 'Subject: N/A';
                const teacherText = task.teacher ? `Teacher: ${task.teacher}` : 'Teacher: N/A';


                taskItem.innerHTML = `
                    <!-- Checkbox -->
                    <input type="checkbox" ${isCompleted ? 'checked' : ''} data-id="${task.id}"
                           class="task-toggle w-5 h-5 text-green-500 bg-white border-white rounded focus:ring-green-400 mr-4 cursor-pointer shadow-inner">

                    <!-- Task Details (Updated structure) -->
                    <div class="flex-grow min-w-0">
                        <!-- Subject Field - Editable -->
                        <p class="editable-field text-sm font-medium text-indigo-700" 
                           data-id="${task.id}" data-field="subject" data-current-value="${task.subject || ''}">
                            ${subjectText}
                        </p>
                        <!-- Title Field - Editable -->
                        <p class="editable-field text-base font-semibold text-indigo-900 truncate" 
                           data-id="${task.id}" data-field="title" data-current-value="${task.title || ''}">
                            ${task.title}
                        </p>
                        <!-- Teacher Field - Editable -->
                        <p class="editable-field text-xs text-indigo-600 mt-0.5" 
                           data-id="${task.id}" data-field="teacher" data-current-value="${task.teacher || ''}">
                            ${teacherText}
                        </p>
                        <!-- Due Date - Not Editable Inline -->
                        <p class="text-xs text-indigo-600 mt-0.5 font-medium">
                            Due: ${formattedDate || 'No Date'}
                        </p>
                    </div>

                    <!-- Delete Button -->
                    <button class="task-delete ml-4 p-2 text-red-500 hover:text-red-700 rounded-full hover:bg-white/80 transition duration-150 ease-in-out" data-id="${task.id}" aria-label="Delete Task">
                        <!-- Icon: Trash -->
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                `;
                
                taskListContainer.appendChild(taskItem);
            });
        }
        
        /**
         * Handles the click on an editable field to enable inline editing.
         */
        function handleFieldEdit(element) {
            const taskId = element.dataset.id;
            const fieldName = element.dataset.field;
            // Use the current value from the data attribute, not innerHTML which includes 'Title: '
            const currentText = element.dataset.currentValue; 
            
            // Determine input type (assuming all are text fields for now, date is done separately)
            const inputType = 'text';

            // Create the input field
            const input = document.createElement('input');
            input.type = inputType;
            input.value = currentText;
            input.className = 'w-full p-1 bg-white/90 rounded-md border border-indigo-400 focus:ring-indigo-500 text-base font-semibold text-indigo-900 shadow-inner';
            
            // Apply field-specific style classes for visual consistency
            if (fieldName === 'subject') {
                input.className = input.className.replace('text-base font-semibold', 'text-sm font-medium');
            } else if (fieldName === 'teacher') {
                input.className = input.className.replace('text-base font-semibold', 'text-xs');
            }
            
            // Replace the <p> element with the <input> element
            element.replaceWith(input);
            input.focus();
            
            // Function to save and revert back to text
            const saveChanges = () => {
                const newValue = input.value;
                if (newValue.trim() !== currentText) {
                    updateTaskField(taskId, fieldName, newValue);
                }
                
                // Re-create the <p> element with the old/new value.
                // onSnapshot will handle the full re-render if the value actually changed.
                const newFieldElement = document.createElement('p');
                // Replicate original classes and data attributes
                newFieldElement.className = element.className;
                newFieldElement.dataset.id = taskId;
                newFieldElement.dataset.field = fieldName;
                newFieldElement.dataset.currentValue = newValue;

                // Re-set text content based on field type
                if (fieldName === 'title') {
                    newFieldElement.textContent = newValue || 'No Title';
                } else if (fieldName === 'subject') {
                    newFieldElement.textContent = `Subject: ${newValue || 'N/A'}`;
                } else if (fieldName === 'teacher') {
                    newFieldElement.textContent = `Teacher: ${newValue || 'N/A'}`;
                }

                input.replaceWith(newFieldElement);
            };

            // Save on blur (click away)
            input.addEventListener('blur', saveChanges);

            // Save on Enter key press
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Prevent form submission
                    input.blur(); // Trigger blur event to save changes
                }
            });
        }


        // --- Event Delegation for Dynamic Elements ---
        taskListContainer.addEventListener('click', (e) => {
            const target = e.target;
            
            // Checkbox Toggle
            if (target.classList.contains('task-toggle')) {
                const taskId = target.dataset.id;
                // Since event is on 'change', checked is the new status. We pass the *old* status to toggle.
                toggleTaskCompletion(taskId, !target.checked); 
            } 
            
            // Delete Button
            else if (target.closest('.task-delete')) {
                const deleteButton = target.closest('.task-delete');
                deleteTask(deleteButton.dataset.id);
            }
            
            // Inline Field Edit (Click on the <p> tag with class 'editable-field')
            else if (target.classList.contains('editable-field')) {
                // Find the parent item to check if it's completed
                const taskItem = target.closest('.task-list-item');
                if (taskItem && !taskItem.classList.contains('completed-task')) {
                    handleFieldEdit(target);
                }
            }
        });


        // --- Event Handlers ---

        /**
         * Handles the form submission for adding a new task.
         */
        taskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const titleInput = document.getElementById('taskTitle');
            const dueDateInput = document.getElementById('taskDueDate');
            const subjectInput = document.getElementById('taskSubject');
            const teacherInput = document.getElementById('taskTeacher'); // Optional

            const title = titleInput.value.trim();
            const dueDate = dueDateInput.value; // YYYY-MM-DD format
            const subject = subjectInput.value.trim();
            const teacher = teacherInput.value.trim();

            if (title && dueDate && subject) {
                addTask(title, dueDate, subject, teacher);
                
                // Clear the main text inputs
                titleInput.value = ''; 
                subjectInput.value = '';
                
                // Keep the date and teacher name for quick subsequent entries
                titleInput.focus();
            }
        });

        // --- Start Application ---
        document.addEventListener('DOMContentLoaded', initializeFirebase);
    </script>
</body>
</html>
